<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ SERVER_NAME }} - Join Plex</title>
  <link rel="icon" type="image/webp" href="{{ url_for('static', filename='favicon.webp', v=favicon_timestamp) }}" />
  <link rel="stylesheet" href="/static/modern-style.css" />
  <script>
    // Set accent color from environment variable
    document.addEventListener('DOMContentLoaded', function() {
      const accentColor = '{{ ACCENT_COLOR }}';
      document.documentElement.style.setProperty('--accent-color', accentColor);
    });
  </script>
</head>
<body>
  {% include "_bottom_nav.html" %}
  
  <!-- Fixed bottom-left service icons -->
  {% if services and QUICK_ACCESS_ENABLED == 'yes' %}
    <div class="quick-access-panel">
      <div class="quick-access-title">Quick Access</div>
      <div class="quick-access-grid">
        {% for service in services %}
          <div class="quick-access-item">
            <a href="{{ service.url }}" target="_blank" title="{{ service.name }}" class="service-link">
              <img src="{{ url_for('static', filename=service.logo) }}" alt="{{ service.name }} logo" class="quick-access-icon">
            </a>
            <div class="quick-access-label">
              {% if service.name == "Plex" %}
                Media
              {% elif service.name == "Audiobookshelf" %}
                Books
              {% elif service.name == "Tautulli" %}
                Stats
              {% elif service.name == "Overseerr" %}
                Request
              {% else %}
                {{ service.name }}
              {% endif %}
            </div>
          </div>
        {% endfor %}
      </div>
    </div>
  {% endif %}

    <div class="onboarding-content">
      <div class="onboarding-section">
        <h1 class="onboarding-title" style="color: white !important; -webkit-text-fill-color: white !important; background: none !important;">Welcome to Plex!</h1>
        <p class="onboarding-intro">
          Plex Media Server (or just <a href="https://support.plex.tv/articles/200288286-what-is-plex/" target="_blank" class="accent">Plex</a>) lets me share my collection of movies and shows with you, just like Netflix, but you don't have to pay. You can watch on your TV, computer, phone, or tablet!
        </p>

        {% set library_list = carousel_libraries|map(attribute='title')|list %}

        <!-- Single Carousel with Library Selector -->
        <div class="carousel-section">
          <div class="poster-carousel-container">
            <div class="poster-carousel animate" id="main-carousel"></div>
          </div>
          
          <div class="library-selector">
            <button class="library-tab {% if default_library == 'random-all' %}active{% endif %}" data-library="random-all">üé≤ Random All</button>
            {% for lib in carousel_libraries %}
              <button class="library-tab {% if default_library == lib.title %}active{% endif %}" data-library="{{ lib.title }}">{{ lib.title }}</button>
            {% endfor %}
          </div>
          
          {% if not carousel_libraries %}
          <div class="info-box">
            <span>‚ÑπÔ∏è</span>
            <span>No library carousels are currently enabled. Please contact the administrator to enable carousels for specific libraries.</span>
          </div>
          {% endif %}
        </div>

        <p class="carousel-note">
          Random selection of posters from each library. Go <a href="/medialists" class="accent" id="medialists-link">here</a> for the full list. <br>
          <span class="mobile-only">On mobile, scroll horizontally to browse through posters.</span>
        </p>

        <h3>Desktop Example</h3>
        <div class="screenshot-section">
          <img src="{{ url_for('static', filename='homepage.webp') }}" alt="Homepage Example" class="toggle-grow" />
          <p class="screenshot-caption">Click to enlarge</p>
        </div>
      </div>

      <details {% if submitted %}open{% endif %} class="collapsible-section">
        <summary class="collapsible-heading">1. Get Access</summary>
          <p>To get started, enter your email below and select what you want access to. Let me know when you're done, and you'll recieve an email or invite link.</p>

          <p class="muted">
            Note: Please don't share the account you create with others. If you know someone who you think would enjoy having access, let me know. In most cases I'll be happy to add them with their own account.
          </p>
          <form method="POST" action="/onboarding" id="onboarding-form">
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <div class="form-group">
              <label for="email" class="form-label">Email:</label>
              <input type="email" name="email" id="email" placeholder="Enter email for Plex" required
                     class="form-input"
                     {% if submitted %}disabled{% endif %} />
            </div>
            <div class="form-group">
              <label class="form-label">Select Libraries:</label>
              <div class="library-list">
                {% for lib in libraries %}
                  <div class="library-item">
                    <input type="checkbox" name="libraries" value="{{ lib.key }}" id="lib_{{ lib.key }}" {% if submitted %}disabled{% endif %} class="library-checkbox" />
                    <label for="lib_{{ lib.key }}" class="library-title">
                      {{ lib.title }}
                    </label>
                    <div class="library-id">
                      {% if library_notes[lib.key|string] and library_notes[lib.key|string]['description'] %}
                        <span class="muted">{{ library_notes[lib.key|string]['description'] }}</span>
                      {% endif %}
                    </div>
                  </div>
                {% endfor %}
              </div>
              {% if has_music_library %}
              <p class="music-note">
                If you picked any audio category, check out Plex's audio app for phones and tablets, Plexamp. You can find a link in "Logging In" below.
              </p>
              {% endif %}
            </div>
            
            <div class="submit-section">
              <button type="submit" class="submit-btn" {% if submitted %}disabled{% endif %}>Submit</button>
            </div>
          </form>
          
          <div class="warning-box">
            <span>‚ö†Ô∏è</span>
            <div>
              <strong>Content Disclaimer</strong><br>
              Some content on my Plex may not be suitable for all ages. I am not responsible for the content available. Users are responsible for their own viewing choices and should exercise appropriate discretion.
            </div>
          </div>
          
          <div id="onboarding-success" style="display:none;">
            <div class="info-box">
              <span>‚úÖ</span>
              <span><strong>Thanks! Your request has been submitted.</strong></span>
            </div>
          </div>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">2. Logging In</summary>
          <p>
            Once you get the invite, go ahead and make a Plex account, and download the app on your device. 
          </p>
          <p>
            <a href="https://www.plex.tv/media-server-downloads/?cat=plex+desktop&plat=windows#plex-app" target="_blank" class="accent">Here</a> is a link to a list of compatible devices with download links.
          </p>
          <p>
           You can also access it via web browser on desktop at <a href="https://app.plex.tv/" target="_blank" class="accent">app.plex.tv</a> to try it out, but I'd prefer if you use the standalone Windows or Mac app. 
          </p>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">3. First Time Setup</summary>
          <p>
            While Plex is generally easy to use, there are some important settings to change the first time you use it.
          </p>

          <p>
            First is the removal of Live TV content provided by Plex. This content has ads and clutters the home page on some devices.
          </p>

          <p>
            To change this setting, use the web or desktop app versions of Plex.
          </p>

          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='newuser1.webp') }}" alt="New User Screenshot" class="toggle-grow" />
            <p class="screenshot-caption">Go to "Online Media Sources"</p>
          </div>
          
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='onlinemedia.webp') }}" alt="Online Media Setting" class="toggle-grow" />
            <p class="screenshot-caption">Disable Live TV, Movies & Shows, and Other Streaming Availability. The others can stay as-is.</p>
          </div>
          
          <p>
            You can poke around in the account settings and change things in the other tabs too.	
          </p>

          <p>
            Next is to increase streaming quality. Check out <a href="https://mediaclients.wiki/Plex" target="_blank" class="accent">this</a> handy guide for getting the best quality stream.
          </p>

          <p>
            If you don't want to read all that, here's the general flow (must be done on every device):
          </p>
          <ul class="text-left max-800">
            <li>Open Plex settings</li>
            <li>Find Video or Quality settings</li>
            <li>Disable any Automatic adjustments</li>
            <li>Change streaming quality to Maximum</li>
            <li>Enable Direct Play/Direct Stream</li>
          </ul>

          <p>
            Note: If you're a nerd and want the best possible Plex experience on your TV, I reccomend one of these: 
          </p>
          <ul class="text-left max-800">
            <li><a href="https://www.amazon.com/s?k=Nvidia+Shield+Pro+%282019%29" target="_blank" class="accent">Nvidia Shield Pro (2019)</a> ‚Äì plays nearly everything flawlessly, best overall.</li>
            <li><a href="https://www.amazon.com/s?k=Apple+TV+4K+%283rd+Gen%29&crid=28HVITCEYC8GN&sprefix=apple+tv+4k+3rd+gen+%2Caps%2C169&ref=nb_sb_noss_2" target="_blank" class="accent">Apple TV 4K (3rd Gen)</a> ‚Äì nearly as good, faster UI, only lacks full TRUEHD passthrough.</li>
            <li><a href="https://www.amazon.com/s?k=FireTV+Cube+%283rd+Gen%29&crid=3KR2YPPAK6S5K&sprefix=firetv+cube+3rd+gen+%2Caps%2C128&ref=nb_sb_noss_2" target="_blank" class="accent">FireTV Cube (3rd Gen)</a> ‚Äì smooth UI, but has DTS playback issues.</li>
          </ul>
          <p>
          Not required unless you notice problems on your current TV device or want the best playback quality.
          </p>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">4. Pinning Libraries</summary>
      
          <h3>Desktop</h3>
          <p>
            Once those settings have been changed, click the home button in the top left (on desktop) and you'll be taken to the page where all the magic happens.
          </p>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='sidemore.webp') }}" alt="Sidebar" class="toggle-grow" />
            <p class="screenshot-caption">Click "More" at the bottom.</p>
          </div>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='unpin.webp') }}" alt="Unpinning" class="toggle-grow" />
            <p class="screenshot-caption">Unpin Playlists, Live TV, Movies & Shows, and Rentals. Make sure my sections at the top are pinned.</p>
          </div>
              
          <h3>Mobile/Tablet</h3>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='mobilehome.webp') }}" alt="Mobile Home Screen" class="toggle-grow" />
            <p class="screenshot-caption">Press and hold "Libraries", go to the all libraries menu, and favorite everything there.</p>
          </div>
          
          <p>
            And you're all set! Browse through my libraries, check out my movie collections (separate tab in Movies library), or put on a comfort show and go to sleep. If you ever want a show or movie that I don't have, see "Requests" below.
          </p>

          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='screens.webp') }}" alt="Screens" class="toggle-grow" />
          </div>
      
      </details>

      {% if pulsarr_enabled or overseerr_enabled %}
      <details class="collapsible-section">
        <summary class="collapsible-heading">5. Requests</summary>
          {% if pulsarr_enabled %}
          <h3>Plex Watchlist Requests</h3>
          <p>
            Through some technomancy, requesting movies and shows you want is pretty easy.
          </p>
          <p>
            We have to be "friends" on Plex (different than adding you to my server) for this feature to work so tell me to do that first before you request anything.
          </p>
          <p class="accent">
            Note: This feature does not work for new movies currently in theaters. Anything older or already on streaming services should be available.
          </p>
          <ul class="text-left max-800">
            <li>Go to the search bar or search menu</li>
            <li>Enable "More Ways to Watch" if not already enabled</li>
            <li>Search for the media you want</li>
            <li>Click the "Add to watchlist" icon</li>
          </ul>
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='watchlist.webp') }}" alt="Watchlist" class="toggle-grow" />
            <p class="screenshot-caption">Click to enlarge</p>
          </div>
          <p>
            Movies should show up in less than 30 minutes. Shows can take longer. The first season will show up to start, and others as you watch. If it's a show that's airing now and you want a more recent season, let me know.
          </p>
          <p class="accent">
            Be nice to my hard drives, don't request too much!
          </p>
          <h3>Notifications</h3>
          <p>
            If I added you as a friend, you can receive notifications on phones and tablets when your Watchlisted media is available. For shows, this only applies when it is added for the first time.{% if tautulli_enabled %} For per-episode notifications about currently airing shows, ask me about my Discord.{% endif %}
          </p>
          <ul class="text-left max-800">
            <li>Make sure notifications are enabled for Plex on your phone (Settings app)</li>
            <li>Go to settings in Plex > Notifications</li>
            <li>Turn off anything you'd like in Plex News, Friends, Discover, Live TV</li>
            <li>Scroll down to Personal Media > New Content Added to Library</li>
            <li>Set the toggles to how they look below (all off except for top one)</li>
          </ul>
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='notifs.webp') }}" alt="Notification Settings" class="toggle-grow" />
          </div>
          {% endif %}
          {% if overseerr_enabled %}
          <h3>Overseerr Requests</h3>
          <p>
            You can request movies and shows directly using Overseerr. Click the link below to open the request page:
          </p>
          <p>
            <a href="{{ overseerr_url }}" target="_blank" class="accent">Open Overseerr</a>
          </p>
          <p class="muted">
            Requests made here will be sent to the admin for approval and processing.
          </p>
          {% endif %}
      </details>
      {% endif %}

      <details class="collapsible-section">
        <summary class="collapsible-heading">{% if pulsarr_enabled or overseerr_enabled %}6{% else %}5{% endif %}. Issues</summary>
      
          <p>
            If you have issues playing a specific piece of media, or it has bad subs, you can report it through Plex or just tell me.
          </p>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='issue.webp') }}" alt="Report Issue" class="toggle-grow" />
          </div>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">{% if pulsarr_enabled or overseerr_enabled %}7{% else %}6{% endif %}. The End</summary>
          {% include "onboarding_section7.html" %}
      </details>
    </div>
  </div>

  <script>
    function handleSubmit(event) {
      // Allow form to submit normally and delay disabling
      setTimeout(() => {
        const inputs = document.querySelectorAll('input, button');
        inputs.forEach(el => el.disabled = true);
      }, 50); // enough time for submit to start

      return true; // let form proceed
    }
  </script>

  <script>
    // AJAX onboarding form submission for Plex
    document.addEventListener('DOMContentLoaded', function() {
      const form = document.getElementById('onboarding-form');
      if (form) {
        form.addEventListener('submit', async function(e) {
          e.preventDefault();
          const formData = new FormData(form);
          const data = new URLSearchParams();
          for (const pair of formData) {
            data.append(pair[0], pair[1]);
          }
          const submitBtn = form.querySelector('button[type="submit"]');
          if (submitBtn) submitBtn.disabled = true;
          Array.from(form.elements).forEach(el => el.disabled = true);
          try {
            const response = await fetch('/onboarding', {
              method: 'POST',
              headers: {
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: data
            });
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                document.getElementById('onboarding-success').style.display = '';
                form.style.display = 'none';
              } else {
                alert(result.error || 'Submission failed.');
                Array.from(form.elements).forEach(el => el.disabled = false);
                if (submitBtn) submitBtn.disabled = false;
              }
            } else {
              alert('Submission failed.');
              Array.from(form.elements).forEach(el => el.disabled = false);
              if (submitBtn) submitBtn.disabled = false;
            }
          } catch (err) {
            alert('Submission failed.');
            Array.from(form.elements).forEach(el => el.disabled = false);
            if (submitBtn) submitBtn.disabled = false;
          }
        });
      }
    });
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Row-based tab switching functionality
      const rowTabs = document.querySelectorAll('.row-tab');
      
      // Library data from template
      const libraryPosters = JSON.parse('{{ library_posters|tojson|safe }}');
      const posterImdbIds = JSON.parse('{{ poster_imdb_ids|tojson|safe if poster_imdb_ids else "{}" }}');
      
      // Track current library
      let currentLibrary = null;
      
      // Helper function to extract title from poster URL
      function getTitleFromPosterUrl(posterUrl) {
        // Extract filename from URL and clean it up for display
        const filename = posterUrl.split('/').pop();
        if (!filename) return 'Unknown Title';
        
        // Remove file extension
        const nameWithoutExt = filename.replace(/\.(webp|jpg|jpeg|png)$/i, '');
        
        // Replace underscores and hyphens with spaces
        const cleanName = nameWithoutExt.replace(/[_-]/g, ' ');
        
        // Capitalize first letter of each word
        return cleanName.replace(/\b\w/g, l => l.toUpperCase());
      }
      
      // Load initial carousel with default library
      const defaultLibrary = '{{ default_library }}';
      const defaultTab = document.querySelector(`.library-tab[data-library="${defaultLibrary}"]`);
      
      console.log('Available library data:', libraryPosters);
      console.log('Default library:', defaultLibrary);
      console.log('Default tab:', defaultTab);
      
      if (defaultTab) {
        console.log(`Loading carousel with ${defaultLibrary}`);
        currentLibrary = defaultLibrary;
        loadCarousel('main-carousel', defaultLibrary);
      } else if (Object.keys(libraryPosters).length === 0) {
        // No libraries available, show message
        const carousel = document.getElementById('main-carousel');
        if (carousel) {
          carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">No library carousels are currently enabled.</div>';
        }
      }
      
      function loadCarousel(carouselId, library) {
        const carousel = document.getElementById(carouselId);
        if (!carousel) {
          console.log(`Carousel ${carouselId} not found`);
          return;
        }
        
        console.log(`Loading carousel ${carouselId} with library ${library}`);
        
        // Stop any existing animation
        if (carousel.rafId) {
          cancelAnimationFrame(carousel.rafId);
          carousel.rafId = null;
        }
        
        // Clear existing content
        carousel.innerHTML = '';
        carousel.style.transform = 'translateX(0px)';
        
        // Reset scroll position for mobile
        const container = carousel.parentElement;
        if (container) {
          container.scrollLeft = 0;
        }
        
        // Show loading state
        carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">Loading posters...</div>';
        
        // Function to fetch random posters from server
        async function fetchRandomPosters(count = 10) {
          try {
            console.log(`Fetching ${count} random posters for library: "${library}"`);
            
            let endpoint = '/ajax/get-random-posters';
            let requestData = {
              count: count
            };
            
            if (library === 'random-all') {
              endpoint = '/ajax/get-random-posters-all';
              requestData.include_music = false;  // Exclude music by default for "Random All"
              console.log('Using random-all endpoint (excluding music)');
            } else {
              requestData.library = library;
            }
            
            console.log('Sending request data:', requestData);
            
            const response = await fetch(endpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: JSON.stringify(requestData)
            });
            
            console.log(`Response status: ${response.status}`);
            console.log(`Response headers:`, Object.fromEntries(response.headers.entries()));
            
            if (response.ok) {
              const data = await response.json();
              console.log(`Received ${data.posters.length} posters from server`);
              return data;
            } else {
              const errorText = await response.text();
              console.error('Failed to fetch random posters:', response.status, errorText);
              
              // Try to parse as JSON for better error info
              try {
                const errorData = JSON.parse(errorText);
                console.error('Error details:', errorData);
              } catch (e) {
                console.error('Raw error response:', errorText);
              }
              
              return { posters: [], imdb_ids: [] };
            }
          } catch (error) {
            console.error('Error fetching random posters:', error);
            return { posters: [], imdb_ids: [] };
          }
        }
        
        // Function to add posters to carousel
        function addPostersToCarousel(posters, imdbIds, lastfmUrls, titles) {
          console.log('Adding posters to carousel:', posters.length);
          // Clear loading state
          carousel.innerHTML = '';
          
          if (posters.length === 0) {
            carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">No posters available for this library</div>';
            console.log('No posters available');
            return;
          }
          
          posters.forEach((poster, index) => {
            const imdbId = imdbIds[index];
            const lastfmUrl = lastfmUrls ? lastfmUrls[index] : null;
            const title = titles ? titles[index] : getTitleFromPosterUrl(poster);
            
            let imgElement;
            if (lastfmUrl) {
              // If it's a music artist, link to Last.fm
              imgElement = `<a href="${lastfmUrl}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else if (imdbId) {
              // If it has IMDB ID, link to IMDB
              imgElement = `<a href="https://www.imdb.com/title/${imdbId}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else {
              // No link - add hover tooltip with title
              imgElement = `<img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" title="${title}" style="opacity: 0; transition: opacity 0.3s ease;">`;
            }
            
            carousel.insertAdjacentHTML('beforeend', imgElement);
          });
          
          // Set up image loading handlers for opacity transitions
          const imgs = carousel.querySelectorAll('img');
          imgs.forEach(img => {
            if (img.complete) {
              // Image is already loaded
              img.style.opacity = '1';
            } else {
              // Image is still loading
              img.addEventListener('load', () => {
                img.style.opacity = '1';
              });
              img.addEventListener('error', () => {
                // Handle failed image loads
                console.log('Image failed to load:', img.src);
              });
            }
          });
          
          console.log(`Added ${posters.length} new posters for ${library}`);
          console.log('Carousel now has', carousel.children.length, 'children');
        }
        
        // Function to append posters to the end of carousel (out of view)
        function appendPostersToCarousel(posters, imdbIds, lastfmUrls, titles, updateObserver = null) {
          if (posters.length === 0) {
            return;
          }
          
          posters.forEach((poster, index) => {
            const imdbId = imdbIds[index];
            const lastfmUrl = lastfmUrls ? lastfmUrls[index] : null;
            const title = titles ? titles[index] : getTitleFromPosterUrl(poster);
            
            let imgElement;
            if (lastfmUrl) {
              // If it's a music artist, link to Last.fm
              imgElement = `<a href="${lastfmUrl}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else if (imdbId) {
              // If it has IMDB ID, link to IMDB
              imgElement = `<a href="https://www.imdb.com/title/${imdbId}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else {
              // No link - add hover tooltip with title
              imgElement = `<img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" title="${title}" style="opacity: 0; transition: opacity 0.3s ease;">`;
            }
            
            carousel.insertAdjacentHTML('beforeend', imgElement);
          });
          
          // Set up image loading handlers for opacity transitions
          const imgs = carousel.querySelectorAll('img');
          imgs.forEach(img => {
            if (img.complete) {
              // Image is already loaded
              img.style.opacity = '1';
            } else {
              // Image is still loading
              img.addEventListener('load', () => {
                img.style.opacity = '1';
              });
              img.addEventListener('error', () => {
                // Handle failed image loads
                console.log('Image failed to load:', img.src);
              });
            }
          });
          
          // Update carousel width after adding new posters
          updateWidth();
          
          // Update intersection observer to watch the new last 4 images
          if (updateObserver) {
            try {
              updateObserver();
            } catch (error) {
              console.error('Error updating intersection observer:', error);
            }
          }
          
          console.log(`Appended ${posters.length} new posters to carousel for ${library}`);
        }
        
        // Function to update carousel width
        function updateWidth() {
          if (carousel.children.length === 0) {
            return;
          }
          
          let totalWidth = 0;
          const gap = parseInt(getComputedStyle(carousel).gap || 0);
          
          Array.from(carousel.children).forEach((img, index) => {
            const imgWidth = img.offsetWidth;
            if (imgWidth === 0) {
              totalWidth += img.naturalWidth + gap;
            } else {
              totalWidth += imgWidth + gap;
            }
          });
          
          carousel.style.width = totalWidth + 'px';
        }
        
        // Function to ensure minimum posters in carousel
        function ensureMinimumPosters() {
          const currentPosters = carousel.children.length;
          if (currentPosters < 8) { // Increased minimum threshold
            console.log(`Only ${currentPosters} posters left, adding more...`);
            // Try to load more posters
            fetchRandomPosters(10).then(data => { // Load more at once
              if (data.posters.length > 0) {
                appendPostersToCarousel(data.posters, data.imdb_ids, [], data.titles || [], updateObserver);
              } else {
                // If AJAX fails, try fallback data
                if (library === 'random-all') {
                  // For random-all, combine all available posters
                  const allPosters = [];
                  const allImdbIds = [];
                  Object.keys(libraryPosters).forEach(libName => {
                    if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                      allPosters.push(...libraryPosters[libName]);
                      const imdbIds = posterImdbIds[libName] || [];
                      allImdbIds.push(...imdbIds);
                    }
                  });
                  if (allPosters.length > 0) {
                    // Get random selection from all posters
                    const indices = [];
                    for (let i = 0; i < Math.min(10, allPosters.length); i++) {
                      indices.push(Math.floor(Math.random() * allPosters.length));
                    }
                    const nextBatch = indices.map(i => allPosters[i]);
                    const nextImdbIds = indices.map(i => allImdbIds[i] || null);
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
                  const posters = libraryPosters[library];
                  const imdbIds = posterImdbIds[library] || [];
                  const nextBatch = posters.slice(0, 10);
                  const nextImdbIds = imdbIds.slice(0, 10);
                  if (nextBatch.length > 0) {
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                }
              }
            }).catch(error => {
              console.error('Error ensuring minimum posters:', error);
            });
          }
        }
        
        // Load initial posters
        fetchRandomPosters(15).then(data => {
          console.log('Fetched initial posters:', data.posters.length);
          if (data.posters.length > 0) {
            addPostersToCarousel(data.posters, data.imdb_ids, data.lastfm_urls, data.titles);
            console.log('Added initial posters, carousel children:', carousel.children.length);
            
            // Wait a moment for images to load, then start animation
            setTimeout(() => {
              console.log('Starting animation after delay, carousel children:', carousel.children.length);
              const updateObserver = setupInfiniteCarousel(carousel, async () => {
                // Load more random posters when needed
                const newData = await fetchRandomPosters(5);
                if (newData.posters.length > 0) {
                  appendPostersToCarousel(newData.posters, newData.imdb_ids, newData.lastfm_urls, newData.titles, updateObserver);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
            }, 500);
          } else {
            // Fallback to original library_posters data if AJAX fails
            console.log('AJAX failed, using fallback data for', library);
            if (library === 'random-all') {
              // For random-all, combine all available posters
              const allPosters = [];
              const allImdbIds = [];
              Object.keys(libraryPosters).forEach(libName => {
                if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                  allPosters.push(...libraryPosters[libName]);
                  const imdbIds = posterImdbIds[libName] || [];
                  allImdbIds.push(...imdbIds);
                }
              });
              if (allPosters.length > 0) {
                // Get random selection from all posters
                const indices = [];
                for (let i = 0; i < Math.min(15, allPosters.length); i++) {
                  indices.push(Math.floor(Math.random() * allPosters.length));
                }
                const initialPosters = indices.map(i => allPosters[i]);
                const initialImdbIds = indices.map(i => allImdbIds[i] || null);
                
                addPostersToCarousel(initialPosters, initialImdbIds, [], []);
                
                // Start animation with fallback loading
                const updateObserver = setupInfiniteCarousel(carousel, () => {
                  // Load more random posters
                  const nextIndices = [];
                  for (let i = 0; i < Math.min(5, allPosters.length); i++) {
                    nextIndices.push(Math.floor(Math.random() * allPosters.length));
                  }
                  const nextBatch = nextIndices.map(i => allPosters[i]);
                  const nextImdbIds = nextIndices.map(i => allImdbIds[i] || null);
                  if (nextBatch.length > 0) {
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                });
                
                // Setup intersection observer for the initial posters
                if (updateObserver) {
                  try {
                    updateObserver();
                  } catch (error) {
                    console.error('Error setting up intersection observer:', error);
                  }
                }
              } else {
                addPostersToCarousel([], [], [], []);
              }
            } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
              const posters = libraryPosters[library];
              const imdbIds = posterImdbIds[library] || [];
              
              // Use first 15 posters from the original data
              const initialPosters = posters.slice(0, 15);
              const initialImdbIds = imdbIds.slice(0, 15);
              
              addPostersToCarousel(initialPosters, initialImdbIds, [], []);
              
              // Start animation with fallback loading
              const updateObserver = setupInfiniteCarousel(carousel, () => {
                // Load more from original data
                const currentCount = carousel.children.length;
                const nextBatch = posters.slice(currentCount, currentCount + 5);
                const nextImdbIds = imdbIds.slice(currentCount, currentCount + 5);
                if (nextBatch.length > 0) {
                  appendPostersToCarousel(nextBatch, nextImdbIds, [], []);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
            } else {
              // No posters available at all
              addPostersToCarousel([], [], []);
            }
          }
        }).catch(error => {
          console.error('Error in initial poster loading:', error);
          // Fallback to original library_posters data
          if (library === 'random-all') {
            // For random-all, combine all available posters
            const allPosters = [];
            const allImdbIds = [];
            Object.keys(libraryPosters).forEach(libName => {
              if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                allPosters.push(...libraryPosters[libName]);
                const imdbIds = posterImdbIds[libName] || [];
                allImdbIds.push(...imdbIds);
              }
            });
            if (allPosters.length > 0) {
              // Get random selection from all posters
              const indices = [];
              for (let i = 0; i < Math.min(15, allPosters.length); i++) {
                indices.push(Math.floor(Math.random() * allPosters.length));
              }
              const initialPosters = indices.map(i => allPosters[i]);
              const initialImdbIds = indices.map(i => allImdbIds[i] || null);
              
              addPostersToCarousel(initialPosters, initialImdbIds);
              
              const updateObserver = setupInfiniteCarousel(carousel, () => {
                // Load more random posters
                const nextIndices = [];
                for (let i = 0; i < Math.min(5, allPosters.length); i++) {
                  nextIndices.push(Math.floor(Math.random() * allPosters.length));
                }
                const nextBatch = nextIndices.map(i => allPosters[i]);
                const nextImdbIds = nextIndices.map(i => allImdbIds[i] || null);
                if (nextBatch.length > 0) {
                  appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
                          } else {
                addPostersToCarousel([], [], [], []);
              }
            } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
            const posters = libraryPosters[library];
            const imdbIds = posterImdbIds[library] || [];
            
            const initialPosters = posters.slice(0, 15);
            const initialImdbIds = imdbIds.slice(0, 15);
            
            addPostersToCarousel(initialPosters, initialImdbIds, [], []);
            
            const updateObserver = setupInfiniteCarousel(carousel, () => {
              const currentCount = carousel.children.length;
              const nextBatch = posters.slice(currentCount, currentCount + 5);
              const nextImdbIds = imdbIds.slice(currentCount, currentCount + 5);
              if (nextBatch.length > 0) {
                appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
              }
            });
            
            // Setup intersection observer for the initial posters
            if (updateObserver) {
              try {
                updateObserver();
              } catch (error) {
                console.error('Error setting up intersection observer:', error);
              }
            }
          } else {
            addPostersToCarousel([], [], [], []);
          }
        });
      }
      
      // Library tab switching functionality
      const libraryTabs = document.querySelectorAll('.library-tab');
      
      // Function to update the medialists link
      function updateMedialistsLink() {
        const medialistsLink = document.getElementById('medialists-link');
        if (medialistsLink) {
          if (currentLibrary === 'random-all') {
            // For random view, go to first available library
            const firstLibraryTab = document.querySelector('.library-tab:not([data-library="random-all"])');
            if (firstLibraryTab) {
              const firstLibrary = firstLibraryTab.getAttribute('data-library');
              medialistsLink.href = `/medialists?service=plex&library=${encodeURIComponent(firstLibrary)}`;
            } else {
              medialistsLink.href = '/medialists';
            }
          } else {
            // For specific library, go to that library's list
            medialistsLink.href = `/medialists?service=plex&library=${encodeURIComponent(currentLibrary)}`;
          }
        }
      }
      
      libraryTabs.forEach(tab => {
        tab.addEventListener('click', function() {
          const targetLibrary = this.getAttribute('data-library');
          
          // Only reload if library actually changed
          if (currentLibrary !== targetLibrary) {
            console.log(`Switching from ${currentLibrary} to ${targetLibrary}`);
            
            // Update active tab
            libraryTabs.forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // Update current library tracking
            currentLibrary = targetLibrary;
            
            // Update medialists link
            updateMedialistsLink();
            
            // Load new carousel data
            loadCarousel('main-carousel', targetLibrary);
          }
        });
      });
      
      // Initialize medialists link
      updateMedialistsLink();

      // Image modal system is now handled by image-modal.js

      // --- Improved Infinite Carousel Logic ---
      function setupInfiniteCarousel(carousel, onLoadMore = null) {
        const container = carousel.parentElement;
        let scrollSpeed = 0.5; // px per frame - increased for better visibility
        let isPaused = false;
        let offset = 0;
        let lastLoadCheck = 0;
        let isLoading = false; // Prevent multiple simultaneous loads

        // Use global mobile detection function from navigation.js
        const isMobile = isMobileDevice();
        
        // Set CSS class on body for styling (already done in navigation.js, but ensure it's set)
        if (isMobile) {
          document.body.classList.add('mobile-device');
          document.body.classList.remove('desktop-device');
        } else {
          document.body.classList.add('desktop-device');
          document.body.classList.remove('mobile-device');
        }
        
        console.log('Carousel setup - Mobile detected:', isMobile);
        console.log('Screen width:', window.innerWidth);
        console.log('Screen height:', window.innerHeight);
        console.log('Pointer type:', window.matchMedia('(pointer: coarse)').matches);
        console.log('Touch support:', 'ontouchstart' in window);
        console.log('Max touch points:', navigator.maxTouchPoints);
        console.log('User agent:', navigator.userAgent);

        // Clear any existing animation and event listeners
        if (carousel.rafId) {
          cancelAnimationFrame(carousel.rafId);
          carousel.rafId = null;
        }
        
        // Remove existing event listeners to prevent duplicates
        if (carousel._mouseEnterHandler) {
          container.removeEventListener('mouseenter', carousel._mouseEnterHandler);
        }
        if (carousel._mouseLeaveHandler) {
          container.removeEventListener('mouseleave', carousel._mouseLeaveHandler);
        }

        // Reset transform
        carousel.style.transform = 'translateX(0px)';
        
        // Check mobile scroll mode from environment
        const mobileScrollMode = '{{ MOBILE_SCROLL_MODE }}' || 'auto';
        console.log('Mobile scroll mode:', mobileScrollMode);
        
        // If manual mode is enabled, disable auto-animation
        if (mobileScrollMode === 'manual') {
          console.log('Manual scroll mode enabled - disabling auto-animation');
          isPaused = true;
        } else {
          console.log('Auto scroll mode enabled - using desktop auto-scroll method');
          // Use the same auto-scroll method as desktop (no mobile-specific handling)
        }
        
        // Add manual scrolling support for touch devices only
        let isUserInteracting = false;
        let manualScrollStartX = 0;
        let manualScrollStartOffset = 0;
        let isManualScrolling = false;
        
        // Only enable manual scrolling on touch devices
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        if (isTouchDevice) {
          // Touch event handling for manual scrolling (touch devices only)
          let touchStartTime = 0;
          let lastTouchMoveTime = 0;
          
          container.addEventListener('touchstart', function(e) {
            isUserInteracting = true;
            isManualScrolling = true;
            manualScrollStartX = e.touches[0].clientX;
            manualScrollStartOffset = offset;
            touchStartTime = Date.now();
            console.log('Manual scroll started - auto-scroll paused');
          }, { passive: true });
          
          container.addEventListener('touchmove', function(e) {
            if (isManualScrolling) {
              const now = Date.now();
              // Throttle touch move events to reduce jumpiness
              if (now - lastTouchMoveTime < 16) { // ~60fps
                return;
              }
              lastTouchMoveTime = now;
              
              // Don't prevent default - let browser handle momentum scrolling
              const deltaX = e.touches[0].clientX - manualScrollStartX;
              // Natural scrolling direction - swipe left moves content left
              let newOffset = manualScrollStartOffset + deltaX;
              
              // Prevent scrolling past available images
              const totalWidth = carousel.scrollWidth || carousel.offsetWidth;
              const containerWidth = container.offsetWidth;
              const maxScroll = Math.max(0, totalWidth - containerWidth);
              
              // Clamp the offset to prevent scrolling beyond available content
              newOffset = Math.max(-maxScroll, Math.min(0, newOffset));
              
              offset = newOffset;
              carousel.style.transform = `translateX(${offset}px)`;
            }
          }, { passive: true }); // Changed back to true for smoother scrolling
          
                          container.addEventListener('touchend', function(e) {
          isManualScrolling = false;
          const touchDuration = Date.now() - touchStartTime;
          
          // Don't prevent default - let momentum scrolling happen naturally
          // The scroll event listener will handle detecting when momentum ends
          
          // Reset interaction flag after a short delay to allow momentum to settle
          setTimeout(() => {
            isUserInteracting = false;
            console.log('Manual scroll ended - auto-scroll resumed');
            // Force immediate animation frame to resume scrolling
            if (carousel.rafId) {
              cancelAnimationFrame(carousel.rafId);
            }
            carousel.rafId = requestAnimationFrame(animate);
          }, 300); // Increased delay to allow momentum to settle
        }, { passive: true });
        
        // Add scroll event listener to detect momentum scrolling end
        let scrollTimeout;
        let lastScrollLeft = 0;
        let scrollStableCount = 0;
        
        container.addEventListener('scroll', function(e) {
          const currentScrollLeft = container.scrollLeft;
          
          // Clear any existing timeout
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          
          // Check if scroll position has stabilized
          if (Math.abs(currentScrollLeft - lastScrollLeft) < 1) {
            scrollStableCount++;
          } else {
            scrollStableCount = 0;
          }
          
          lastScrollLeft = currentScrollLeft;
          
          // Set a timeout to detect when scrolling has completely stopped
          scrollTimeout = setTimeout(() => {
            // Only resume auto-scroll if scroll has been stable for multiple checks
            if (scrollStableCount >= 3) {
              isUserInteracting = false;
              console.log('Momentum scrolling ended - auto-scroll resumed');
              // Force immediate animation frame to resume scrolling
              if (carousel.rafId) {
                cancelAnimationFrame(carousel.rafId);
              }
              carousel.rafId = requestAnimationFrame(animate);
            }
          }, 100); // Shorter timeout for more responsive detection
        }, { passive: true });
      }
      
      // Quick poster loading when near the end (for auto-scroll)
        function checkForMorePosters() {
          if (onLoadMore && !isLoading) {
            const remainingImages = carousel.children.length;
            if (remainingImages <= 15) {
              console.log('Near end during auto-scroll - loading more posters quickly!');
              isLoading = true;
              onLoadMore().then(() => {
                isLoading = false;
                console.log('Poster loading completed successfully');
              }).catch(error => {
                console.error('Error loading more posters:', error);
                isLoading = false;
                ensureMinimumPosters();
              });
            }
          }
        }

        // Setup intersection observer to detect when last few images come into view
        function setupIntersectionObserver() {
          console.log('Setting up intersection observer...');
          console.log('onLoadMore available:', !!onLoadMore);
          console.log('IntersectionObserver available:', !!window.IntersectionObserver);
          
          if (!onLoadMore || !window.IntersectionObserver) {
            console.log('Intersection observer setup failed - missing requirements');
            return null;
          }
          
          let lastTriggerTime = 0;
          const minTriggerInterval = 0; 
          
          const observer = new IntersectionObserver((entries) => {
            console.log('Intersection observer triggered:', entries.length, 'entries');
            entries.forEach(entry => {
              console.log('Entry:', entry.isIntersecting, 'target:', entry.target);
              const now = Date.now();
              if (entry.isIntersecting && !isLoading && (now - lastTriggerTime) > minTriggerInterval) {
                console.log('Last few images are now visible - triggering load');
                lastTriggerTime = now;
                isLoading = true;
                onLoadMore().then(() => {
                  console.log('onLoadMore completed successfully');
                  isLoading = false;
                }).catch(error => {
                  console.error('Error loading more posters:', error);
                  isLoading = false;
                  ensureMinimumPosters();
                });
              } else {
                console.log('Intersection observer conditions not met:', {
                  isIntersecting: entry.isIntersecting,
                  isLoading: isLoading,
                  timeSinceLastTrigger: now - lastTriggerTime,
                  minInterval: minTriggerInterval
                });
              }
            });
          }, {
            root: null, // Use viewport instead of container
            rootMargin: '100px', // Trigger when 100px away from viewport
            threshold: 0.1
          });

          // Function to observe the last few images
          function observeLastImages() {
            console.log('Updating intersection observer...');
            // Disconnect previous observations
            observer.disconnect();
            
            const images = Array.from(carousel.children);
            console.log('Total images in carousel:', images.length);
            if (images.length >= 5) {
              // Observe all of the last 5 images
              const last5Images = images.slice(-5);
              console.log('Observing last 5 images:', last5Images.length);
              
              last5Images.forEach((img, index) => {
                if (img) {
                  observer.observe(img);
                  console.log(`Now observing image ${images.length - 5 + index + 1} of ${images.length}`);
                }
              });
            } else {
              console.log('Not enough images to observe (need at least 5, have', images.length, ')');
            }
          }

          // Initial setup
          observeLastImages();

          // Return function to update observation when new images are added
          return observeLastImages;
        }

        // Setup the intersection observer (optional)
        const updateObserver = setupIntersectionObserver();
        if (updateObserver) {
          console.log('Intersection observer setup successful');
        } else {
          console.log('Intersection observer not available, using fallback method');
        }
        
        // Debug: Log animation state
        console.log('Animation setup - isPaused:', isPaused, 'isUserInteracting:', isUserInteracting, 'scrollSpeed:', scrollSpeed);

        // Set carousel width
        function updateWidth() {
          if (carousel.children.length === 0) {
            console.log('No children in carousel for width calculation');
            return;
          }
          
          let totalWidth = 0;
          const gap = parseInt(getComputedStyle(carousel).gap || 0);
          
          Array.from(carousel.children).forEach((img, index) => {
            const imgWidth = img.offsetWidth;
            if (imgWidth === 0) {
              console.log(`Image ${index} has zero width, using naturalWidth`);
              totalWidth += img.naturalWidth + gap;
            } else {
              totalWidth += imgWidth + gap;
            }
          });
          
          carousel.style.width = totalWidth + 'px';
          console.log(`Carousel width set to: ${totalWidth}px`);
        }
        
        // Update width immediately and after a short delay
        updateWidth();
        setTimeout(updateWidth, 100);

        // Animation loop using transform
        function animate() {
          try {
            // Don't animate if there are no images or if we have a loading/error message
            if (carousel.children.length === 0 || carousel.querySelector('div')) {
              console.log('Animation skipped - no children or loading message');
              carousel.rafId = requestAnimationFrame(animate);
              return;
            }
            
            // Pause on hover or when user is manually scrolling
            if (!isPaused && !isUserInteracting) {
              // Check if we have enough images before scrolling
              if (carousel.children.length < 3) {
                console.log('Not enough images to scroll, pausing animation');
                carousel.rafId = requestAnimationFrame(animate);
                return;
              }
              
              // Debug: log when animation resumes after manual scroll
              if (Math.random() < 0.01) { // Log occasionally when animation is running
                console.log('Animation active - offset:', offset, 'children:', carousel.children.length, 'isLoading:', isLoading);
              }
              
              offset -= scrollSpeed;
              carousel.style.transform = `translateX(${offset}px)`;
              // Debug: log animation state occasionally
              if (Math.random() < 0.001) { // Very rare logging
                console.log('Animation running - offset:', offset, 'isPaused:', isPaused, 'isUserInteracting:', isUserInteracting, 'children:', carousel.children.length);
              }
              
              // Remove images that have scrolled completely off screen, but maintain minimum
              const firstImg = carousel.children[0];
              if (firstImg && (firstImg.tagName === 'IMG' || firstImg.tagName === 'A') && carousel.children.length > 5) {
                const firstImgWidth = firstImg.offsetWidth + parseInt(getComputedStyle(carousel).gap || 0);
                if (Math.abs(offset) >= firstImgWidth) {
                  firstImg.remove();
                  offset += firstImgWidth;
                  carousel.style.transform = `translateX(${offset}px)`;
                  
                  // Update width after removing image
                  updateWidth();
                  console.log('Removed image, remaining children:', carousel.children.length);
                }
              }
              
              // Fallback: Check if we need to load more posters (every 2 seconds as backup)
              const now = Date.now();
              if (now - lastLoadCheck > 2000) {
                lastLoadCheck = now;
                checkForMorePosters();
              }
            }
            carousel.rafId = requestAnimationFrame(animate);
          } catch (error) {
            console.error('Animation error:', error);
            // Stop animation on error
            if (carousel.rafId) {
              cancelAnimationFrame(carousel.rafId);
              carousel.rafId = null;
            }
          }
        }
        
        // Start animation immediately
        console.log(`Starting animation for carousel ${carousel.id}`);
        console.log('Animation state - isPaused:', isPaused, 'isUserInteracting:', isUserInteracting);
        console.log('Carousel children count:', carousel.children.length);
        animate();
        
        // Return the observer update function
        return updateObserver;

        // Pause on hover - store handlers to prevent duplicates
        carousel._mouseEnterHandler = () => { 
          isPaused = true; 
          console.log('Carousel paused on hover');
        };
        carousel._mouseLeaveHandler = () => { 
          isPaused = false; 
          console.log('Carousel resumed on mouse leave');
        };
        container.addEventListener('mouseenter', carousel._mouseEnterHandler);
        container.addEventListener('mouseleave', carousel._mouseLeaveHandler);
        
        // Periodic safety check to ensure carousel doesn't become empty
        setInterval(() => {
          if (carousel.children.length < 5) {
            console.log('Carousel running low on posters, adding more...');
            ensureMinimumPosters();
          }
        }, 3000); // Check every 3 seconds (reduced from 5)
      }
    });
  </script>

  <!-- Image Modal Script -->
  <script src="{{ url_for('static', filename='image-modal.js') }}"></script>
  
  <!-- Navigation Script -->
  <script src="{{ url_for('static', filename='navigation.js') }}"></script>

</body>
</html>
