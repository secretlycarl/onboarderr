<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ SERVER_NAME }} - Join Plex</title>
  <link rel="icon" type="image/webp" href="{{ url_for('static', filename='favicon.webp', v=favicon_timestamp) }}" />
  <link rel="stylesheet" href="/static/modern-style.css" />
  <script>
    // Set accent color from environment variable
    document.addEventListener('DOMContentLoaded', function() {
      const accentColor = '{{ ACCENT_COLOR }}';
      document.documentElement.style.setProperty('--accent-color', accentColor);
    });
  </script>
  
  <!-- Debug Utilities -->
  <script src="{{ url_for('static', filename='debug-utils.js') }}"></script>
</head>
  <body>
  <script>
    // Initialize debug state from server
    window.DEBUG_ENABLED = {{ JS_DEBUG|lower }};
  </script>
  {% include "_bottom_nav.html" %}
  
  <!-- Fixed bottom-left service icons -->
  {% include "_quick_access_panel.html" %}

    <div class="onboarding-content">
      <div class="onboarding-section">
        <h1 class="onboarding-title" style="color: white !important; -webkit-text-fill-color: white !important; background: none !important;">Welcome to Plex!</h1>
        <p class="onboarding-intro">
          Plex Media Server (or just <a href="https://support.plex.tv/articles/200288286-what-is-plex/" target="_blank" class="accent">Plex</a>) lets me share my collection of movies and shows with you, just like Netflix, but you don't have to pay. You can watch on your TV, computer, phone, or tablet!
        </p>

        <p class="onboarding-intro">
          See below to request access and check out the setup instructions.
        </p>

        {% set library_list = carousel_libraries|map(attribute='title')|list %}

        <!-- Single Carousel with Library Selector -->
        <div class="carousel-section">
          <div class="poster-carousel-container">
            <div class="poster-carousel animate" id="main-carousel"></div>
          </div>
          
          {% if carousel_libraries|length > 1 %}
          <div class="library-selector">
            <button class="library-tab {% if default_library == 'random-all' %}active{% endif %}" data-library="random-all">üé≤ Random All</button>
            {% for lib in carousel_libraries %}
              <button class="library-tab {% if default_library == lib.title %}active{% endif %}" data-library="{{ lib.title }}">{{ lib.title }}</button>
            {% endfor %}
          </div>
          {% endif %}
          
          {% if not carousel_libraries %}
          <div class="info-box">
            <span>‚ÑπÔ∏è</span>
            <span>No library carousels are currently enabled. Please contact the administrator to enable carousels for specific libraries.</span>
          </div>
          {% endif %}
        </div>

        <p class="carousel-note">
          {% if carousel_libraries|length > 1 %}
          Random selection of posters from each library. Go <a href="/medialists" class="accent" id="medialists-link">here</a> for the full list. <br>
          <span class="mobile-only">On mobile, scroll horizontally to browse through posters.</span>
          {% else %}
          Random selection of posters from my library. Go <a href="/medialists" class="accent" id="medialists-link">here</a> for the full list. <br>
          <span class="mobile-only">On mobile, scroll horizontally to browse through posters.</span>
          {% endif %}
        </p>

        <h3>Desktop and Mobile UI</h3>
        <div class="screenshot-section">
          <img src="{{ url_for('static', filename='homepage.webp') }}" alt="Homepage Example" class="toggle-grow" />
          <p class="screenshot-caption">Click to enlarge</p>
        </div>
      </div>

      <details {% if submitted %}open{% endif %} class="collapsible-section">
        <summary class="collapsible-heading">1. Get Access</summary>
          <p>To get started, enter your email below and select what you want access to. Let me know when you're done, and you'll recieve an email or invite link.</p>

          <p class="muted">
            Note: Please don't share the account you create with others. If you know someone who you think would enjoy having access, let me know. In most cases I'll be happy to add them with their own account.
          </p>
          <form method="POST" action="/onboarding" id="onboarding-form">
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <div class="form-group">
              <label for="email" class="form-label">Email:</label>
              <input type="email" name="email" id="email" placeholder="Enter email for Plex" required
                     class="form-input"
                     {% if submitted %}disabled{% endif %} />
            </div>
            <div class="form-group">
              <label class="form-label">Select Libraries:</label>
              <div class="library-list">
                {% for lib in libraries %}
                  <div class="onboarding-library-item">
                    <input type="checkbox" name="libraries" value="{{ lib.key }}" id="lib_{{ lib.key }}" {% if submitted %}disabled{% endif %} class="library-checkbox" />
                    <label for="lib_{{ lib.key }}" class="library-title">
                      {{ lib.title }}
                    </label>
                    <div class="library-id">
                      {% if library_notes[lib.key|string] and library_notes[lib.key|string]['description'] %}
                        <span class="muted">{{ library_notes[lib.key|string]['description'] }}</span>
                      {% endif %}
                    </div>
                  </div>
                {% endfor %}
              </div>
              {% if has_music_library %}
              <p class="music-note">
                If you picked any audio category, check out Plex's audio app for phones and tablets, Plexamp. You can find a link in "Logging In" below.
              </p>
              {% endif %}
            </div>
            
            <div class="submit-section">
              <button type="submit" class="submit-btn" {% if submitted %}disabled{% endif %}>Submit</button>
            </div>
          </form>

          <div id="onboarding-success" style="display:none;">
            <div class="info-box">
              <span>‚úÖ</span>
              <span><strong>Thanks! Your request has been submitted.</strong></span>
            </div>
          </div>
          
          <div id="onboarding-duplicate-warning" style="display:none;">
            <div class="warning-box">
              <span>‚ö†Ô∏è</span>
              <span><strong>Email already submitted!</strong> This email address has already been used for a request. Please use a different email address or contact the administrator if you need to update your request.</span>
            </div>
          </div>
          
          <div class="warning-box">
            <span>‚ö†Ô∏è</span>
            <div>
              <strong>Content Disclaimer</strong><br>
              Some content on my Plex may not be suitable for all ages. I am not responsible for the content available. Users are responsible for their own viewing choices and should exercise appropriate discretion.
            </div>
          </div>
          
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">2. Logging In</summary>
          <p>
            Once you get the invite, go ahead and make a Plex account, then download the app on your device. 
          </p>
          <p>
            <a href="https://www.plex.tv/media-server-downloads/?cat=plex+desktop&plat=windows#plex-app" target="_blank" class="accent">Here</a> is a link to a list of compatible devices with download links. Most smart TVs have a Plex app.
          </p>
          <p>
           You can also access it via web browser on desktop at <a href="https://app.plex.tv/" target="_blank" class="accent">app.plex.tv</a> to try it out, but I'd prefer if you use the standalone Windows or Mac app. 
          </p>

          <h3>Login Screenshots</h3>
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='plexlogin.webp') }}" alt="Login Examples" class="toggle-grow" />
          </div>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">3. First Time Setup</summary>
          <p>
            Plex is pretty easy to use, but there are  important settings to change the first time you open it up.
          </p>

          <p>
            First is the removal of Live TV content provided by Plex. This content has ads and clutters the home page on some devices.
          </p>

          <p>
            To change this setting, use the web or desktop app versions of Plex.
          </p>

          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='newuser1.webp') }}" alt="New User Screenshot" class="toggle-grow" />
            <p class="screenshot-caption">Go to "Online Media Sources"</p>
          </div>
          
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='onlinemedia.webp') }}" alt="Online Media Setting" class="toggle-grow" />
            <p class="screenshot-caption">Disable Live TV, Movies & Shows, and Other Streaming Availability. The others can stay as-is.</p>
          </div>
          
          <p>
            You can poke around in the account settings (I recommend you turn on automatic login) and change things in the other tabs too.
          </p>

          <hr class="section-divider">

          <p>
            Next is to increase streaming quality. Check out <a href="https://mediaclients.wiki/Plex" target="_blank" class="accent">this</a> handy guide for getting the best quality stream.
          </p>

          <p>
            If you don't want to read all that, here's the general flow (must be done on every device):
          </p>
          <ul class="text-left max-800">
            <li>Open Plex settings</li>
            <li>Find Video or Quality settings</li>
            <li>Disable any Automatic adjustments</li>
            <li>Change streaming quality to Maximum</li>
            <li>Enable Direct Play/Direct Stream</li>
          </ul>

          <hr class="section-divider">

          <p>
            If you're a nerd and want the best possible Plex experience on your TV, I recommend one of these: 
          </p>
          <ul class="text-left max-800">
            <li><a href="https://www.amazon.com/s?k=Nvidia+Shield+Pro+%282019%29" target="_blank" class="accent">Nvidia Shield Pro (2019)</a> ‚Äì plays nearly everything flawlessly, best overall</li>
            <li><a href="https://www.amazon.com/s?k=Apple+TV+4K+%283rd+Gen%29&crid=28HVITCEYC8GN&sprefix=apple+tv+4k+3rd+gen+%2Caps%2C169&ref=nb_sb_noss_2" target="_blank" class="accent">Apple TV 4K (3rd Gen)</a> ‚Äì nearly as good, faster UI, only lacks full TRUEHD passthrough</li>
            <li><a href="https://www.amazon.com/s?k=FireTV+Cube+%283rd+Gen%29&crid=3KR2YPPAK6S5K&sprefix=firetv+cube+3rd+gen+%2Caps%2C128&ref=nb_sb_noss_2" target="_blank" class="accent">FireTV Cube (3rd Gen)</a> ‚Äì smooth UI, but has DTS playback issues</li>
          </ul>
          <p>
          Not needed unless you have problems on your current TV or want the absolute best playback quality.
          </p>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">4. Pinning Libraries</summary>
      
          <h3>Desktop</h3>
          <p>
            Once those settings have been changed, click the home button in the top left and you'll be taken to the page where all the magic happens.
          </p>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='sidemore.webp') }}" alt="Sidebar" class="toggle-grow" />
            <p class="screenshot-caption">Click "More" at the bottom.</p>
          </div>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='unpin.webp') }}" alt="Unpinning" class="toggle-grow" />
            <p class="screenshot-caption">Unpin Playlists, Live TV, Movies & Shows, and Rentals. Make sure my sections at the top are pinned.</p>
          </div>
              
          <h3>Mobile/Tablet</h3>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='mobilehome.webp') }}" alt="Mobile Home Screen" class="toggle-grow" />
            <p class="screenshot-caption">Press and hold "Libraries", go to the all libraries menu, and favorite everything there.</p>
          </div>
          
          <p>
            And you're all set! Browse through my libraries, check out my movie collections (separate tab in Movies library), or put on a comfort show and go to sleep. If you ever want a show or movie that I don't have, see "Requests" below.
          </p>

          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='screens.webp') }}" alt="Screens" class="toggle-grow" />
          </div>
      
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">5. Requests</summary>
          {% if pulsarr_enabled or overseerr_enabled or jellyseerr_enabled %}
            {% if pulsarr_enabled %}
            <h3>Plex Watchlist Requests</h3>
            <p>
              I have an easy to use system for requesting/adding movies and shows you want to my Plex.
            </p>
            <p>
              We have to be "friends" on Plex (different than adding you to my server) for this feature to work so tell me to do that first.
            </p>
            <p class="accent">
              Note: Requesting does not work for new movies currently in theaters. Anything older or already on streaming services should be available.
            </p>
            <ul class="text-left max-800">
              <li>Go to the search bar or search menu</li>
              <li>Enable "More Ways to Watch" if not already enabled</li>
              <li>Search for the media you want</li>
              <li>Click the "Add to watchlist" icon</li>
            </ul>
            <div class="screenshot-section">
              <img src="{{ url_for('static', filename='watchlist.webp') }}" alt="Watchlist" class="toggle-grow" />
            </div>
            <p>
              Movies should show up in less than 30 minutes, but shows can take longer.
            </p>
            <p>
              For shows, the first season will be available initially, and others will show up as you watch. If it's a show that's airing now and you want a more recent season, let me know.
            </p>
            <p class="accent">
              Be nice to my hard drives, don't request too much!
            </p>
            <h3>Notifications</h3>
            <p>
              If I added you as a friend, you can receive notifications on phones and tablets when your requested movie, show season, or episode is available.
            </p>
            <ul class="text-left max-800">
              <li>Make sure notifications are enabled for Plex on your device (Settings app)</li>
              <li>Go to settings in Plex > Notifications</li>
              <li>Turn off anything you'd like in Plex News, Friends, Discover, Live TV</li>
              <li>Scroll down to Personal Media > New Content Added to Library</li>
              <li>Set the toggles to how they look below (all off except for top one)</li>
            </ul>
            <div class="screenshot-section">
              <img src="{{ url_for('static', filename='notifs.webp') }}" alt="Notification Settings" class="toggle-grow" />
            </div>
            {% endif %}
            {% if overseerr_enabled %}
            <h3>Overseerr Requests</h3>
            <p>
              You can request movies and shows directly using Overseerr.
            </p>
            <p>
              Click the link below to open the request page:
            </p>
            <p>
              <a href="{{ overseerr_url }}" target="_blank" class="accent">Open Overseerr</a>
            </p>
            <p class="muted">
              Requests made here will be sent to me for approval and processing.
            </p>
            {% endif %}
            {% if jellyseerr_enabled %}
            <h3>Jellyseerr Requests</h3>
            <p>
              You can request movies and shows directly using Jellyseerr.
            </p>
            <p>
              Click the link below to open the request page:
            </p>
            <p>
              <a href="{{ jellyseerr_url }}" target="_blank" class="accent">Open Jellyseerr</a>
            </p>
            <p class="muted">
              Requests made here will be sent to me for approval and processing.
            </p>
            {% endif %}
          {% else %}
            <p>
              If you want a movie or show I don't have, just ask. I should be able to help you out.
            </p>
          {% endif %}
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">6. Issues</summary>
      
          <p>
            If you have issues playing a specific piece of media, find a movie or episode with bad subs, or any other issues, you can report it through Plex or just tell me.
          </p>
      
          <div class="screenshot-section">
            <img src="{{ url_for('static', filename='issue.webp') }}" alt="Report Issue" class="toggle-grow" />
          </div>
      </details>

      <details class="collapsible-section">
        <summary class="collapsible-heading">7. The End</summary>
        <p>
          {{ section7_content.personal_message }}
        </p>
        
        {% if section7_content.payment_services and section7_content.payment_services|length > 0 %}
          {% set valid_services = [] %}
          {% for service in section7_content.payment_services %}
            {% if service.title and service.handle %}
              {% set _ = valid_services.append(service) %}
            {% endif %}
          {% endfor %}
          
          {% if valid_services|length > 0 %}
          <p>
            Donate to my hard drive fund:
          </p>
          
          <ul class="text-left max-800">
            {% for service in valid_services %}
              <li>{{ service.title }} - <b>{{ service.handle }}</b></li>
            {% endfor %}
          </ul>
          {% endif %}
        {% endif %}
        
        <!-- 
        <p>
          <a href="https://ko-fi.com/secretlycarl" target="_blank" class="accent">
            <img src="https://cdn.ko-fi.com/cdn/kofi3.png?v=3" alt="Buy Me a Coffee at ko-fi.com" style="height:36px;">
          </a>
        </p> 
        -->
      </details>
    </div>
  </div>

  <script>
    function handleSubmit(event) {
      // Allow form to submit normally and delay disabling
      setTimeout(() => {
        const inputs = document.querySelectorAll('input, button');
        inputs.forEach(el => el.disabled = true);
      }, 50); // enough time for submit to start

      return true; // let form proceed
    }
  </script>

  <script>
    // AJAX onboarding form submission for Plex
    document.addEventListener('DOMContentLoaded', function() {
      const form = document.getElementById('onboarding-form');
      if (form) {
        form.addEventListener('submit', async function(e) {
          e.preventDefault();
          const formData = new FormData(form);
          const data = new URLSearchParams();
          for (const pair of formData) {
            data.append(pair[0], pair[1]);
          }
          const submitBtn = form.querySelector('button[type="submit"]');
          if (submitBtn) submitBtn.disabled = true;
          Array.from(form.elements).forEach(el => el.disabled = true);
          
          // Hide any existing warning messages
          document.getElementById('onboarding-duplicate-warning').style.display = 'none';
          
          try {
            const response = await fetch('/onboarding', {
              method: 'POST',
              headers: {
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: data
            });
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                document.getElementById('onboarding-success').style.display = '';
                form.style.display = 'none';
              } else {
                if (result.error && result.error.includes('already been submitted')) {
                  // Show duplicate email warning
                  document.getElementById('onboarding-duplicate-warning').style.display = '';
                  // Re-enable form for correction
                  Array.from(form.elements).forEach(el => el.disabled = false);
                  if (submitBtn) submitBtn.disabled = false;
                } else {
                  alert(result.error || 'Submission failed.');
                  Array.from(form.elements).forEach(el => el.disabled = false);
                  if (submitBtn) submitBtn.disabled = false;
                }
              }
            } else {
              alert('Submission failed.');
              Array.from(form.elements).forEach(el => el.disabled = false);
              if (submitBtn) submitBtn.disabled = false;
            }
          } catch (err) {
            alert('Submission failed.');
            Array.from(form.elements).forEach(el => el.disabled = false);
            if (submitBtn) submitBtn.disabled = false;
          }
        });
      }
    });
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Make onboarding library items clickable on mobile
      const libraryItems = document.querySelectorAll('.onboarding-library-item');
      
      libraryItems.forEach(item => {
        item.addEventListener('click', function(e) {
          // Don't trigger if clicking directly on the checkbox or its label
          if (e.target.type === 'checkbox' || e.target.tagName === 'LABEL') {
            return;
          }
          
          // Find the checkbox within this item
          const checkbox = this.querySelector('input[type="checkbox"]');
          if (checkbox && !checkbox.disabled) {
            checkbox.checked = !checkbox.checked;
            // Trigger change event for form validation
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        // Add cursor pointer for better UX
        item.style.cursor = 'pointer';
      });

      // Row-based tab switching functionality
      const rowTabs = document.querySelectorAll('.row-tab');
      
      // Library data from template
      const libraryPosters = JSON.parse('{{ library_posters|tojson|safe }}');
      const posterImdbIds = JSON.parse('{{ poster_imdb_ids|tojson|safe if poster_imdb_ids else "{}" }}');
      
      // Track current library
      let currentLibrary = null;
      
      // Library selector scrollbar hiding functionality
      const librarySelector = document.querySelector('.library-selector');
      if (librarySelector) {
        let hasScrolled = false;
        let scrollTimeout;
        
        // Function to check if library selector should be centered
        const checkLibrarySelectorCentering = () => {
          if (librarySelector.scrollWidth <= librarySelector.clientWidth) {
            librarySelector.classList.add('centered');
          } else {
            librarySelector.classList.remove('centered');
          }
        };
        
        // Check centering on load and resize
        checkLibrarySelectorCentering();
        window.addEventListener('resize', checkLibrarySelectorCentering);
        
        // Scrollbar fade functionality
        let hasInteracted = false;
        let fadeTimeout;
        
        // Add scrolling class when user scrolls
        librarySelector.addEventListener('scroll', () => {
          hasInteracted = true;
          librarySelector.classList.add('scrolling');
          
          // Add fade class after first interaction
          librarySelector.classList.add('scrollbar-faded');
          
          // Clear existing timeout
          if (fadeTimeout) {
            clearTimeout(fadeTimeout);
          }
          
          // Remove scrolling class after 2 seconds of no scrolling
          fadeTimeout = setTimeout(() => {
            if (!librarySelector.matches(':hover')) {
              librarySelector.classList.remove('scrolling');
            }
          }, 2000);
        });
        
        // Show scrollbar on hover
        librarySelector.addEventListener('mouseenter', () => {
          if (hasInteracted) {
            librarySelector.classList.remove('scrollbar-faded');
          }
        });
        
        // Hide scrollbar when leaving (if already interacted)
        librarySelector.addEventListener('mouseleave', () => {
          if (hasInteracted) {
            librarySelector.classList.add('scrollbar-faded');
          }
        });

      }
      
      // Helper function to extract title from poster URL
      function getTitleFromPosterUrl(posterUrl) {
        // Extract filename from URL and clean it up for display
        const filename = posterUrl.split('/').pop();
        if (!filename) return 'Unknown Title';
        
        // Remove file extension
        const nameWithoutExt = filename.replace(/\.(webp|jpg|jpeg|png)$/i, '');
        
        // Replace underscores and hyphens with spaces
        const cleanName = nameWithoutExt.replace(/[_-]/g, ' ');
        
        // Capitalize first letter of each word
        return cleanName.replace(/\b\w/g, l => l.toUpperCase());
      }
      
      // Load initial carousel with default library
      const defaultLibrary = '{{ default_library }}';
      const defaultTab = document.querySelector(`.library-tab[data-library="${defaultLibrary}"]`);
      const availableLibraryTabs = document.querySelectorAll('.library-tab');
      const hasMultipleLibraries = availableLibraryTabs.length > 1;
      
      if (hasMultipleLibraries && defaultTab) {
        // Multiple libraries available, use default library
        currentLibrary = defaultLibrary;
        loadCarousel('main-carousel', defaultLibrary);
      } else if (!hasMultipleLibraries && Object.keys(libraryPosters).length === 1) {
        // Only one library available, load it directly
        const singleLibrary = Object.keys(libraryPosters)[0];
        console.log(`Single library detected, loading ${singleLibrary}`);
        currentLibrary = singleLibrary;
        loadCarousel('main-carousel', singleLibrary);
      } else if (Object.keys(libraryPosters).length === 0) {
        // No libraries available, show message
        const carousel = document.getElementById('main-carousel');
        if (carousel) {
          carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">No library carousels are currently enabled.</div>';
        }
      }
      
      function loadCarousel(carouselId, library) {
        const carousel = document.getElementById(carouselId);
        if (!carousel) {
          console.log(`Carousel ${carouselId} not found`);
          return;
        }
        
        console.log(`Loading carousel ${carouselId} with library ${library}`);
        console.log('Available library posters:', libraryPosters);
        console.log('Library posters for this library:', libraryPosters[library]);
        
        // Stop any existing animation
        if (carousel.rafId) {
          cancelAnimationFrame(carousel.rafId);
          carousel.rafId = null;
        }
        
        // Clear existing content
        carousel.innerHTML = '';
        carousel.style.transform = 'translateX(0px)';
        
        // Reset scroll position for mobile
        const container = carousel.parentElement;
        if (container) {
          container.scrollLeft = 0;
        }
        
        // Show loading state
        carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">Loading posters...</div>';
        
        // Function to fetch random posters from server
        async function fetchRandomPosters(count = 10) {
          try {
            console.log(`Fetching ${count} random posters for library: "${library}"`);
            
            let endpoint = '/ajax/get-random-posters';
            let requestData = {
              count: count
            };
            
            if (library === 'random-all') {
              endpoint = '/ajax/get-random-posters-all';
              requestData.include_music = false;  // Exclude music by default for "Random All"
              console.log('Using random-all endpoint (excluding music)');
            } else {
              requestData.library = library;
            }
            
            console.log('Sending request data:', requestData);
            
            const response = await fetch(endpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: JSON.stringify(requestData)
            });
            
            console.log(`Response status: ${response.status}`);
            console.log(`Response headers:`, Object.fromEntries(response.headers.entries()));
            
            if (response.ok) {
              const data = await response.json();
              console.log(`Received ${data.posters.length} posters from server`);
              return data;
            } else {
              const errorText = await response.text();
              console.error('Failed to fetch random posters:', response.status, errorText);
              
              // Try to parse as JSON for better error info
              try {
                const errorData = JSON.parse(errorText);
                console.error('Error details:', errorData);
              } catch (e) {
                console.error('Raw error response:', errorText);
              }
              
              return { posters: [], imdb_ids: [] };
            }
          } catch (error) {
            console.error('Error fetching random posters:', error);
            return { posters: [], imdb_ids: [] };
          }
        }
        
        // Function to add posters to carousel
        function addPostersToCarousel(posters, imdbIds, lastfmUrls, titles) {
          console.log('Adding posters to carousel:', posters.length);
          // Clear loading state
          carousel.innerHTML = '';
          
          if (posters.length === 0) {
            carousel.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 200px; color: #888;">No posters available for this library</div>';
            console.log('No posters available');
            return;
          }
          
          posters.forEach((poster, index) => {
            const imdbId = imdbIds[index];
            const lastfmUrl = lastfmUrls ? lastfmUrls[index] : null;
            const title = titles ? titles[index] : getTitleFromPosterUrl(poster);
            
            let imgElement;
            if (lastfmUrl) {
              // If it's a music artist, link to Last.fm
              imgElement = `<a href="${lastfmUrl}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else if (imdbId) {
              // If it has IMDB ID, link to IMDB
              imgElement = `<a href="https://www.imdb.com/title/${imdbId}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else {
              // No link - add hover tooltip with title
              imgElement = `<img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" title="${title}" style="opacity: 0; transition: opacity 0.3s ease;">`;
            }
            
            carousel.insertAdjacentHTML('beforeend', imgElement);
          });
          
          // Set up image loading handlers for opacity transitions
          const imgs = carousel.querySelectorAll('img');
          imgs.forEach(img => {
            if (img.complete) {
              // Image is already loaded
              img.style.opacity = '1';
            } else {
              // Image is still loading
              img.addEventListener('load', () => {
                img.style.opacity = '1';
              });
              img.addEventListener('error', () => {
                // Handle failed image loads
                console.log('Image failed to load:', img.src);
              });
            }
          });
          
          console.log(`Added ${posters.length} new posters for ${library}`);
          console.log('Carousel now has', carousel.children.length, 'children');
        }
        
        // Function to append posters to the end of carousel (out of view)
        function appendPostersToCarousel(posters, imdbIds, lastfmUrls, titles, updateObserver = null) {
          if (posters.length === 0) {
            return;
          }
          
          posters.forEach((poster, index) => {
            const imdbId = imdbIds[index];
            const lastfmUrl = lastfmUrls ? lastfmUrls[index] : null;
            const title = titles ? titles[index] : getTitleFromPosterUrl(poster);
            
            let imgElement;
            if (lastfmUrl) {
              // If it's a music artist, link to Last.fm
              imgElement = `<a href="${lastfmUrl}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else if (imdbId) {
              // If it has IMDB ID, link to IMDB
              imgElement = `<a href="https://www.imdb.com/title/${imdbId}" target="_blank" class="accent" title="${title}"><img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;"></a>`;
            } else {
              // No link - add hover tooltip with title
              imgElement = `<img src="${poster}" class="carousel-img" alt="${library} poster" loading="lazy" title="${title}" style="opacity: 0; transition: opacity 0.3s ease;">`;
            }
            
            carousel.insertAdjacentHTML('beforeend', imgElement);
          });
          
          // Set up image loading handlers for opacity transitions
          const imgs = carousel.querySelectorAll('img');
          imgs.forEach(img => {
            if (img.complete) {
              // Image is already loaded
              img.style.opacity = '1';
            } else {
              // Image is still loading
              img.addEventListener('load', () => {
                img.style.opacity = '1';
              });
              img.addEventListener('error', () => {
                // Handle failed image loads
                console.log('Image failed to load:', img.src);
              });
            }
          });
          
          // Update carousel width after adding new posters
          updateWidth();
          
          // Update intersection observer to watch the new last 4 images
          if (updateObserver) {
            try {
              updateObserver();
            } catch (error) {
              console.error('Error updating intersection observer:', error);
            }
          }
          
          console.log(`Appended ${posters.length} new posters to carousel for ${library}`);
        }
        
        // Function to update carousel width
        function updateWidth() {
          if (carousel.children.length === 0) {
            return;
          }
          
          let totalWidth = 0;
          const gap = parseInt(getComputedStyle(carousel).gap || 0);
          
          Array.from(carousel.children).forEach((img, index) => {
            const imgWidth = img.offsetWidth;
            if (imgWidth === 0) {
              totalWidth += img.naturalWidth + gap;
            } else {
              totalWidth += imgWidth + gap;
            }
          });
          
          carousel.style.width = totalWidth + 'px';
        }
        
        // Function to ensure minimum posters in carousel
        function ensureMinimumPosters() {
          const currentPosters = carousel.children.length;
          if (currentPosters < 8) { // Increased minimum threshold
            console.log(`Only ${currentPosters} posters left, adding more...`);
            // Try to load more posters
            fetchRandomPosters(10).then(data => { // Load more at once
              if (data.posters.length > 0) {
                appendPostersToCarousel(data.posters, data.imdb_ids, [], data.titles || [], updateObserver);
              } else {
                // If AJAX fails, try fallback data
                if (library === 'random-all') {
                  // For random-all, combine all available posters
                  const allPosters = [];
                  const allImdbIds = [];
                  Object.keys(libraryPosters).forEach(libName => {
                    if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                      allPosters.push(...libraryPosters[libName]);
                      const imdbIds = posterImdbIds[libName] || [];
                      allImdbIds.push(...imdbIds);
                    }
                  });
                  if (allPosters.length > 0) {
                    // Get random selection from all posters
                    const indices = [];
                    for (let i = 0; i < Math.min(10, allPosters.length); i++) {
                      indices.push(Math.floor(Math.random() * allPosters.length));
                    }
                    const nextBatch = indices.map(i => allPosters[i]);
                    const nextImdbIds = indices.map(i => allImdbIds[i] || null);
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
                  const posters = libraryPosters[library];
                  const imdbIds = posterImdbIds[library] || [];
                  const nextBatch = posters.slice(0, 10);
                  const nextImdbIds = imdbIds.slice(0, 10);
                  if (nextBatch.length > 0) {
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                }
              }
            }).catch(error => {
              console.error('Error ensuring minimum posters:', error);
            });
          }
        }
        
        // Load initial posters
        fetchRandomPosters(15).then(data => {
          console.log('Fetched initial posters:', data.posters.length);
          if (data.posters.length > 0) {
            addPostersToCarousel(data.posters, data.imdb_ids, data.lastfm_urls, data.titles);
            console.log('Added initial posters, carousel children:', carousel.children.length);
            
            // Wait a moment for images to load, then start animation
            setTimeout(() => {
              console.log('Starting animation after delay, carousel children:', carousel.children.length);
              const updateObserver = setupInfiniteCarousel(carousel, async () => {
                // Load more random posters when needed
                const newData = await fetchRandomPosters(5);
                if (newData.posters.length > 0) {
                  appendPostersToCarousel(newData.posters, newData.imdb_ids, newData.lastfm_urls, newData.titles, updateObserver);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
            }, 500);
          } else {
            // Fallback to original library_posters data if AJAX fails
            console.log('AJAX failed, using fallback data for', library);
            if (library === 'random-all') {
              // For random-all, combine all available posters
              const allPosters = [];
              const allImdbIds = [];
              Object.keys(libraryPosters).forEach(libName => {
                if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                  allPosters.push(...libraryPosters[libName]);
                  const imdbIds = posterImdbIds[libName] || [];
                  allImdbIds.push(...imdbIds);
                }
              });
              if (allPosters.length > 0) {
                // Get random selection from all posters
                const indices = [];
                for (let i = 0; i < Math.min(15, allPosters.length); i++) {
                  indices.push(Math.floor(Math.random() * allPosters.length));
                }
                const initialPosters = indices.map(i => allPosters[i]);
                const initialImdbIds = indices.map(i => allImdbIds[i] || null);
                
                addPostersToCarousel(initialPosters, initialImdbIds, [], []);
                
                // Start animation with fallback loading
                const updateObserver = setupInfiniteCarousel(carousel, () => {
                  // Load more random posters
                  const nextIndices = [];
                  for (let i = 0; i < Math.min(5, allPosters.length); i++) {
                    nextIndices.push(Math.floor(Math.random() * allPosters.length));
                  }
                  const nextBatch = nextIndices.map(i => allPosters[i]);
                  const nextImdbIds = nextIndices.map(i => allImdbIds[i] || null);
                  if (nextBatch.length > 0) {
                    appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                  }
                });
                
                // Setup intersection observer for the initial posters
                if (updateObserver) {
                  try {
                    updateObserver();
                  } catch (error) {
                    console.error('Error setting up intersection observer:', error);
                  }
                }
              } else {
                addPostersToCarousel([], [], [], []);
              }
            } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
              const posters = libraryPosters[library];
              const imdbIds = posterImdbIds[library] || [];
              
              // Use first 15 posters from the original data
              const initialPosters = posters.slice(0, 15);
              const initialImdbIds = imdbIds.slice(0, 15);
              
              addPostersToCarousel(initialPosters, initialImdbIds, [], []);
              
              // Start animation with fallback loading
              const updateObserver = setupInfiniteCarousel(carousel, () => {
                // Load more from original data
                const currentCount = carousel.children.length;
                const nextBatch = posters.slice(currentCount, currentCount + 5);
                const nextImdbIds = imdbIds.slice(currentCount, currentCount + 5);
                if (nextBatch.length > 0) {
                  appendPostersToCarousel(nextBatch, nextImdbIds, [], []);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
            } else {
              // No posters available at all
              addPostersToCarousel([], [], []);
            }
          }
        }).catch(error => {
          console.error('Error in initial poster loading:', error);
          // Fallback to original library_posters data
          if (library === 'random-all') {
            // For random-all, combine all available posters
            const allPosters = [];
            const allImdbIds = [];
            Object.keys(libraryPosters).forEach(libName => {
              if (libraryPosters[libName] && libraryPosters[libName].length > 0) {
                allPosters.push(...libraryPosters[libName]);
                const imdbIds = posterImdbIds[libName] || [];
                allImdbIds.push(...imdbIds);
              }
            });
            if (allPosters.length > 0) {
              // Get random selection from all posters
              const indices = [];
              for (let i = 0; i < Math.min(15, allPosters.length); i++) {
                indices.push(Math.floor(Math.random() * allPosters.length));
              }
              const initialPosters = indices.map(i => allPosters[i]);
              const initialImdbIds = indices.map(i => allImdbIds[i] || null);
              
              addPostersToCarousel(initialPosters, initialImdbIds);
              
              const updateObserver = setupInfiniteCarousel(carousel, () => {
                // Load more random posters
                const nextIndices = [];
                for (let i = 0; i < Math.min(5, allPosters.length); i++) {
                  nextIndices.push(Math.floor(Math.random() * allPosters.length));
                }
                const nextBatch = nextIndices.map(i => allPosters[i]);
                const nextImdbIds = nextIndices.map(i => allImdbIds[i] || null);
                if (nextBatch.length > 0) {
                  appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
                }
              });
              
              // Setup intersection observer for the initial posters
              if (updateObserver) {
                try {
                  updateObserver();
                } catch (error) {
                  console.error('Error setting up intersection observer:', error);
                }
              }
                          } else {
                addPostersToCarousel([], [], [], []);
              }
            } else if (libraryPosters[library] && libraryPosters[library].length > 0) {
            const posters = libraryPosters[library];
            const imdbIds = posterImdbIds[library] || [];
            
            const initialPosters = posters.slice(0, 15);
            const initialImdbIds = imdbIds.slice(0, 15);
            
            addPostersToCarousel(initialPosters, initialImdbIds, [], []);
            
            const updateObserver = setupInfiniteCarousel(carousel, () => {
              const currentCount = carousel.children.length;
              const nextBatch = posters.slice(currentCount, currentCount + 5);
              const nextImdbIds = imdbIds.slice(currentCount, currentCount + 5);
              if (nextBatch.length > 0) {
                appendPostersToCarousel(nextBatch, nextImdbIds, [], [], updateObserver);
              }
            });
            
            // Setup intersection observer for the initial posters
            if (updateObserver) {
              try {
                updateObserver();
              } catch (error) {
                console.error('Error setting up intersection observer:', error);
              }
            }
          } else {
            addPostersToCarousel([], [], [], []);
          }
        });
      }
      
      // Library tab switching functionality
      const libraryTabs = document.querySelectorAll('.library-tab');
      
      // Function to update the medialists link
      function updateMedialistsLink() {
        const medialistsLink = document.getElementById('medialists-link');
        if (medialistsLink) {
          if (currentLibrary === 'random-all') {
            // For random view, go to first available library
            const firstLibraryTab = document.querySelector('.library-tab:not([data-library="random-all"])');
            if (firstLibraryTab) {
              const firstLibrary = firstLibraryTab.getAttribute('data-library');
              medialistsLink.href = `/medialists?service=plex&library=${encodeURIComponent(firstLibrary)}`;
            } else {
              medialistsLink.href = '/medialists';
            }
          } else {
            // For specific library, go to that library's list
            medialistsLink.href = `/medialists?service=plex&library=${encodeURIComponent(currentLibrary)}`;
          }
        }
      }
      
      libraryTabs.forEach(tab => {
        tab.addEventListener('click', function() {
          const targetLibrary = this.getAttribute('data-library');
          
          // Only reload if library actually changed
          if (currentLibrary !== targetLibrary) {
            // Update active tab
            libraryTabs.forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // Update current library tracking
            currentLibrary = targetLibrary;
            
            // Update medialists link
            updateMedialistsLink();
            
            // Load new carousel data
            loadCarousel('main-carousel', targetLibrary);
          }
        });
      });
      
      // Initialize medialists link
      updateMedialistsLink();

      // Image modal system is now handled by image-modal.js

      // --- AUTO-SCROLL CAROUSEL LOGIC ---
      function setupInfiniteCarousel(carousel, onLoadMore = null) {
        const container = carousel.parentElement;
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        

        
        // Clear any existing auto-scroll instance
        if (carousel.autoScrollInstance) {
          carousel.autoScrollInstance.destroy();
          carousel.autoScrollInstance = null;
        }
        
        // Clear any existing animation
        if (carousel.rafId) {
          cancelAnimationFrame(carousel.rafId);
          carousel.rafId = null;
        }
        
        // Remove existing event listeners to prevent duplicates
        if (carousel._mouseEnterHandler) {
          container.removeEventListener('mouseenter', carousel._mouseEnterHandler);
        }
        if (carousel._mouseLeaveHandler) {
          container.removeEventListener('mouseleave', carousel._mouseLeaveHandler);
        }
        if (carousel._touchStartHandler) {
          container.removeEventListener('touchstart', carousel._touchStartHandler);
        }
        if (carousel._touchEndHandler) {
          container.removeEventListener('touchend', carousel._touchEndHandler);
        }
        if (carousel._scrollHandler) {
          container.removeEventListener('scroll', carousel._scrollHandler);
        }

        // Reset transform
        carousel.style.transform = 'translateX(0px)';
        
        // Set carousel width for proper scrolling
        function updateWidth() {
          if (carousel.children.length === 0) {
            return;
          }
          
          let totalWidth = 0;
          const gap = parseInt(getComputedStyle(carousel).gap || 0);
          
          Array.from(carousel.children).forEach((img, index) => {
            const imgWidth = img.offsetWidth;
            if (imgWidth === 0) {
              totalWidth += img.naturalWidth + gap;
            } else {
              totalWidth += imgWidth + gap;
            }
          });
          
          carousel.style.width = totalWidth + 'px';
        }
        
        // Update width immediately and after a short delay
        updateWidth();
        setTimeout(updateWidth, 100);
        
        // Initialize auto-scroll with appropriate settings
        const autoScrollOptions = {
          scrollSpeed: 0.5, // px per frame - from old implementation
          pauseOnHover: true,
          pauseOnInteraction: true,
          resumeDelay: 1000, // 1 second delay after user interaction
          minPosters: 8,
          loadMoreThreshold: 15,
          onLoadMore: onLoadMore
        };
        
        // Initialize the auto-scroll instance
        carousel.autoScrollInstance = window.initializeCarouselAutoScroll(carousel.id, autoScrollOptions);
        
        // Setup intersection observer for poster loading
        const updateObserver = setupIntersectionObserver();
        if (updateObserver) {
          debugLog('Intersection observer setup successful');
        }
        
        // Periodic safety check to ensure carousel doesn't become empty
        const safetyCheckInterval = debugSetInterval(() => {
          if (carousel.children.length < 5) {
            debugLog('Carousel running low on posters, adding more...');
            if (onLoadMore) {
              onLoadMore().then(() => {
                updateWidth();
              }).catch(error => {
                debugError('Error loading more posters:', error);
              });
            }
          }
        }, 3000);
        
        // Return the observer update function
        return updateObserver;
        
        // Setup intersection observer to detect when last few images come into view
        function setupIntersectionObserver() {
          debugLog('Setting up intersection observer...');
          debugLog('onLoadMore available:', !!onLoadMore);
          debugLog('IntersectionObserver available:', !!window.IntersectionObserver);
          
          if (!onLoadMore || !window.IntersectionObserver) {
            debugLog('Intersection observer setup failed - missing requirements');
            return null;
          }
          
                  let lastTriggerTime = 0;
        const minTriggerInterval = 200; // Increased from 0 to 200ms to prevent rapid loading during fast scrolling
        
        const observer = new IntersectionObserver((entries) => {
          debugLog('Intersection observer triggered:', entries.length, 'entries');
          entries.forEach(entry => {
            debugLog('Entry:', entry.isIntersecting, 'target:', entry.target);
            const now = Date.now();
            if (entry.isIntersecting && (now - lastTriggerTime) > minTriggerInterval) {
              debugLog('Last few images are now visible - triggering load');
              lastTriggerTime = now;
              onLoadMore().then(() => {
                debugLog('onLoadMore completed successfully');
              }).catch(error => {
                debugError('Error loading more posters:', error);
              });
            }
          });
        }, {
            root: null, // Use viewport instead of container
            rootMargin: '100px', // Trigger when 100px away from viewport
            threshold: 0.1
          });

          // Function to observe the last few images
          function observeLastImages() {
            debugLog('Updating intersection observer...');
            // Disconnect previous observations
            observer.disconnect();
            
            const images = Array.from(carousel.children);
            debugLog('Total images in carousel:', images.length);
            if (images.length >= 5) {
              // Observe all of the last 5 images
              const last5Images = images.slice(-5);
              debugLog('Observing last 5 images:', last5Images.length);
              
              last5Images.forEach((img, index) => {
                if (img) {
                  observer.observe(img);
                  debugLog(`Now observing image ${images.length - 5 + index + 1} of ${images.length}`);
                }
              });
            } else {
              debugLog('Not enough images to observe (need at least 5, have', images.length, ')');
            }
          }

          // Initial setup
          observeLastImages();

          // Return function to update observation when new images are added
          return observeLastImages;
        }
      }
    });
  </script>

  <!-- Carousel Auto-Scroll Script -->
  <script src="{{ url_for('static', filename='carousel-auto-scroll.js') }}"></script>
  
  <!-- Image Modal Script -->
  <script src="{{ url_for('static', filename='image-modal.js') }}"></script>
  
  <!-- Navigation Script -->
  <script src="{{ url_for('static', filename='navigation.js') }}"></script>

  <!-- Smooth Background Extension Script -->
  <script src="{{ url_for('static', filename='smooth-background.js') }}"></script>

  <!-- Quick Access Panel Script -->
  <script src="{{ url_for('static', filename='quick-access.js') }}"></script>
  
  <!-- Debug Utilities -->
  <script src="{{ url_for('static', filename='debug-utils.js') }}"></script>
  <script>
    // Initialize debug state from server
    window.DEBUG_ENABLED = {{ JS_DEBUG|lower }};
  </script>

</body>
</html>
